# !! fix sar code generation bug in bcc3 for div2(...), div4(...) etc. in bcc3

#include <stdio.h>

int div2(i) int i; { return i / 2; }
int div3(i) int i; { return i / 3; }
int div4(i) int i; { return i / 4; }
int div10(i) int i; { return i / 10; }
int divsi2() { return -1 / 2; }
int divsi10() { return -1 / 10; }

int main() {
  printf("Hello, World! divsign=%d,%d div=%d,%d,%d,%d\n", divsi2(), divsi10(), div2(-1), div3(-1), div4(-1), div10(-1));
  return 0;
}

Code generated by OpenWatcom v2 for i386, ruining EDX and EFLAGS:

div2:
 cdq
 sub eax, edx
 sar eax, 1

div4:
 cdq
 shl edx, 2
 sbb eax, edx
 sar eax, 2

div8:
 cdq
 shl edx, 3
 sbb eax, edx
 sar eax, 3

div16:
 cdq
 shl edx, 4
 sbb eax, edx
 sar eax, 4

div32:
 cdq
 shl edx, 5
 sbb eax, edx
 sar eax, 5

div64:
 cdq
 shl edx, 6
 sbb eax, edx
 sar eax, 6

Another approach, ruining EDX and EFLAGS:

div8:
 cdq           ; Sign-extend EAX into EDX. EDX = 0xFFFFFFFF if EAX < 0, else 0x0.
 and edx, 7    ; EDX = 7 if EAX < 0, else 0.
 add eax, edx  ; Add bias of 7 to negative numbers.
 sar eax, 3    ; Arithmetic shift right by 3.
