title	cpp		C Pre-Processor
index			C pre-processor

synopsis
	.s.nf
	cpp [-options] [infile [outfile]]
	.s.f
description

	CPP reads a C source file, expands macros and include
	files, and writes an input file for the C compiler.
	If no file arguments are given, CPP reads from stdin
	and writes to stdout.  If one file argument is given,
	it will define the input file, while two file arguments
	define both input and output files.  The file name "-"
	is a synonym for stdin or stdout as appropriate.

	The following options are supported.  Options may
	be given in either case.
	.lm +16
	.p -16
	-C		If set, source-file comments are written
	to the output file.  This allows the output of CPP to be
	used as the input to a program, such as lint, that expects
	commands embedded in specially-formatted comments.
	.p -16
	-Dname=value	Define the name as if the programmer wrote

	    #define name value

	at the start of the first file.  If "=value" is not
	given, a value of "1" will be used.

	On non-unix systems, all alphabetic text will be forced
	to upper-case.
	.p -16
	-E		Always return "success" to the operating
	system, even if errors were detected.  Note that some fatal
	errors, such as a missing #include file, will terminate
	CPP, returning "failure" even if the -E option is given.
	.p -16
	-Idirectory	Add this directory to the list of
	directories searched for #include "..." and #include <...>
	commands.  Note that there is no space between the
	"-I" and the directory string.  More than one -I command
	is permitted.  On non-Unix systems "directory" is forced
	to upper-case.
	.p -16
	-N		CPP normally predefines some symbols defining
	the target computer and operating system.  If -N is specified,
	no symbols will be predefined.  If -N -N is specified, the
	"always present" symbols, __LINE__, __FILE__, and __DATE__
	are not defined.
	.p -16
	-P		CPP normally writes lines of the form
	#line <number> <file.name> to the output file so the compiler
	can print the line number and name of the original source file
	for diagnostic messages.  The -P option will suppress this output.
	.p -16
	-Stext		CPP normally assumes that the size of
	the target computer's basic variable types is the same as the size
	of these types of the host computer.  (This can be overridden
	when CPP is compiled, however.)  The -S option allows dynamic
	respecification of these values.  "text" is a string of
	numbers, separated by commas, that specifies correct sizes.
	The sizes must be specified in the exact order:

	    char short int long float double

	If you specify the option as "-S*text", pointers to these
	types will be specified.  -S* takes one additional argument
	for pointer to function (e.g. int (*)())

	For example, to specify sizes appropriate for a PDP-11,
	you would write:

	       c s i l f d func
	     -S1,2,2,2,4,8,
	    -S*2,2,2,2,2,2,2

	Note that all values must be specified.
	.p -16
	-Tnumber	Enable (number = 1) or disable
	trigraph recognition.  (If no number is given, the
	default state is reversed.)  If enabled, the sequence
	"??" is a character-escape to allow certain characters
	to be entered on systems where the normal representation
	is used for national letters.  This implementation
	"merely" converts the trigraph to the internal representation,
	and thus is probably incorrect.  A correct implementation
	would seem to require recognition of Ansi escape sequences
	in the input stream.  Someone else can write that routine.
	.p -16
	-Uname		Undefine the name as if

	    #undef name

	were given.  On non-Unix systems, "name" will be forced to
	upper-case.
	.p -16
	-Xnumber	Enable debugging code.  If no value is
	given, a value of 1 will be used.  (For maintenence of
	CPP only.)
	.s.lm -16

Pre-Defined Variables

	When CPP begins processing, the following variables will
	have been defined (unless the -N option is specified):
	.s
	Target computer (as appropriate):
	.s
	    pdp11, vax, M68000 m68000 m68k
	.s
	Target operating system (as appropriate):
	.s
	    rsx, rt11, vms, unix
	.s
	Target compiler (as appropriate):
	.s
	    decus, vax11c
	.s
	The implementor may add definitions to this list.
	The default definitions match the definition of the
	host computer, operating system, and C compiler.
	.s
	The following are always available unless undefined (or
	-N was specified twice):
	.lm +16
	.p -12
	__FILE__	The input (or #include) file being compiled
	(as a quoted string).
	.p -12
	__LINE__	The line number being compiled.
	.p -12
	__DATE__	The date and time of compilation as
	a Unix ctime quoted string (the trailing newline is removed).
	Thus,
	.s
	    printf("Bug at line %s,", __LINE__);
	    printf(" source file %s", __FILE__);
	    printf(" compiled on %s", __DATE__);
	.s.lm -16

Draft Proposed Ansi Standard Considerations

	The current version of the Draft Proposed Standard
	explicitly states that "readers are requested not to specify
	or claim conformance to this draft."  Readers and users
	of Decus CPP should not assume that Decus CPP conforms
	to the standard, or that it will conform to the actual
	C Language Standard.

	When CPP is itself compiled, many features of the Draft
	Proposed Standard that are incompatible with existing
	preprocessors may be disabled.  See the comments in CPP's
	source for details.

	The latest version of the Draft Proposed Standard (as reflected
	in Decus CPP) is dated November 12, 1984.

	Comments are removed from the input text.  The comment
	is replaced by a single space character.  The -C option
	preserves comments, writing them to the output file.

	The '$' character is considered to be a letter.  This is
	a permitted extension.

	The following new features of C are processed by CPP:
	.s.comment Note: significant spaces, not tabs, .br quotes #if, #elif
	.br;####_#elif expression    (_#else _#if)
	.br;####'_\xNNN'             (Hexadecimal constant)
	.br;####'_\a'                (Ascii BELL)
	.br;####'_\v'                (Ascii Vertical Tab)
	.br;####_#if defined NAME    1 if defined, 0 if not
	.br;####_#if defined (NAME)  1 if defined, 0 if not  
	.br;####_#if sizeof (basic type)
	.br;####unary +
	.br;####123U, 123LU          Unsigned ints and longs.
	.br;####12.3L                Long double numbers
	.br;####token_#token         Token concatenation
	.br;####_#include token      Expands to filename

	The Draft Proposed Standard has extended C, adding a constant
	string concatenation operator, where

	    "foo" "bar"

	is regarded as the single string "foobar".  (This does not
	affect CPP's processing but does permit a limited form of
	macro argument substitution into strings as will be discussed.)

	The Standard Committee plans to add token concatenation
	to #define command lines.  One suggested implementation
	is as follows:  the sequence "Token1#Token2" is treated
	as if the programmer wrote "Token1Token2".  This could
	be used as follows:

	    #line 123
	    #define ATLINE foo#__LINE__

	ATLINE would be defined as foo123.

	Note that "Token2" must either have the format of an
	identifier or be a string of digits.  Thus, the string

	    #define ATLINE foo#1x3

	generates two tokens: "foo1" and "x3".

	If the tokens T1 and T2 are concatenated into T3,
	this implementation operates as follows:

	  1. Expand T1 if it is a macro.
	  2. Expand T2 if it is a macro.
	  3. Join the tokens, forming T3.
	  4. Expand T3 if it is a macro.

	A macro formal parameter will be substituted into a string
	or character constant if it is the only component of that
	constant:

	    #define VECSIZE 123
	    #define vprint(name, size) \
	      printf("name" "[" "size" "] = {\n")
	      ... vprint(vector, VECSIZE);

	expands (effectively) to

	      vprint("vector[123] = {\n");

	Note that this will be useful if your C compiler supports
	the new string concatenation operation noted above.
	As implemented here, if you write

	    #define string(arg) "arg"
	      ... string("foo") ...

	This implementation generates "foo", rather than the strictly
	correct ""foo"" (which will probably generate an error message).
	This is, strictly speaking, an error in CPP and may be removed
	from future releases.

error messages

	Many.  CPP prints warning or error messages if you try to
	use multiple-byte character constants (non-transportable)
	if you #undef a symbol that was not defined, or if your
	program has potentially nested comments.

author

	Martin Minow

bugs

	The #if expression processor uses signed integers only.
	I.e, #if 0xFFFFu < 0 may be TRUE.

