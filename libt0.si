|
| libt0.si: part of the Minix libc implemented in 8086 (i86) assembly, BCC as (non-asld) special syntax
| based on Minix 1.5.10 libc and Minix 1.5.10 BCC libc source files: crtso.s sendrec.s brksize.s idiv.s idivu.s imodu.s imul.s laddl.s landl.s lcmpl.s lcoml.s ldecl.s ldivl.s ldivul.s leorl.s lincl.s lmodl.s lmodul.s lmull.s lnegl.s lorl.s lsll.s lsrl.s lsrul.s lsubl.s ltstl.s
| modified and size-optimized by pts@fazekas.hu at Mon Jan 12 22:25:29 CET 2026
|
| The Minix 1.5.10 i86 calling convention is the following:
|
| * Upon each function entry and exit: ES == DS == SS.
| * Upon each function entry and exit: DF == 0. (This is only the convention of this libc. The default Minix libc doesn't have it.)
| * Please note that the callee can use BX as a scratch register, in addition to the usual AX, CX and DX in cdecl. (In the i386 calling convention, the caller has to restore EBX.)
| * The following assumes that all function arguments and return values are 1 byte (char, unsigned char) or 2 bytes (e.g. int, unsigned, pointer) or long (4 bytes) or unsigned long (4 bytes).
| * The caller pushes arguments starting with the last (sign-extended or zero-extended if needed first), one word a at a time, does a `call', and then pops the arguments.
| * The callee can use AX, BX, CX, DX and FLAGS as scratch registers (but must set DF := 0). It must restore all other registers (including SI, DI, BP, DS, ES).
| * The callee returns the value in AX (sign-extended or zero-extended if needed), it returns long and unsigned long values in DX:AX.
| * The caller must ensure that ES == .data (same as DS and SS) before the function call.
|
| Assembly syntax compatibility of this file:
|
| * asld (auto -0):  no, because it uses .comm
| * v0 as -0:        yes
| * v0 as -0 -a:     yes
| * v0 as -3:        yes
| * v0 as -3 -a:     yes
| * v1 as -0:        yes, see compatibility hack below
| * v1 as -0 -a:     yes
| * v1 as -3:        yes
| * v1 as -3 -a:     yes
|

use16  | compatibility hack: by specifying use16 8 times in a row, we enable asld_compatible (as -a) mode in as v1, which actually adds compatibility with as v0 (with or without -a), for this file. It makes the effective address in `mov ax, 2(bx)' etc. work.
use16  | Manual syntax conversion (`mov ax, 2(bx)' --> `mov ax, [bx+2]'): perl -pe 's@((?:-?\d+)?)\((bx|si|di|bp)\)@[$2+$1]@g and s@[+]([-\]])@$1@g'
use16
use16
use16
use16
use16
use16

.data
.zerow 2  | food for null pointer bugs
.extern _end
.globl _brksize
_brksize: .word _end
.bss
|.extern __M
.comm __M, 24  | message _M;
.text

| See <minix/com.h> for C definitions
|SEND = 1
|RECEIVE = 2
BOTH = 3
SYSVEC = 32  | int 20h | int $20

| --- Startup and syscalls.

| This is the C run-time start-off routine.  It's job is to take the
| arguments as put on the stack by EXEC, and to parse them and set them up the
| way _main expects them.
.globl crtso
.extern _main
crtso:
	cld
	|sub bp, bp  | clear for backtrace of core files
	pop cx  | CX := argc.
	mov bx, sp  | BX := argv.
	|push ax  | push environ
	push bx  | push argv
	push cx  | push argc
	call _main
	|add sp, *6  | Not needed, we are exiting soon anyway.
	push ax  | push exit status
	push ax  | Fake return address for _exit.
	| Fall through to _exit.

| void exit(int exit_code)
.globl _exit
_exit:
| PUBLIC void exit(exit_code)
| int exit_code;
| {
|   *(char*)&_M.m_type = EXIT;
|   _M.m1_i1 = exit_code;
|   callx();
| }
	pop ax  | Return address. Won't be used.
	pop [__M+4]  | exit_code.
	movb [__M+2], *1  | *(char*)&_M.m_type = EXIT;
	| Fall through to _callx.

| Send a message and get the response.  The '_M.m_type' field of the
| reply contains a value (>=0) or an error code (<0).
.globl _callx
_callx:
| PRIVATE int callx()
| {
|   int k;
| #ifdef DEBUG_MALLOC  /* Always false. */
|   k = _M.m_type;  /* syscall number. */
|   k = (k >= READ && k <= CREAT) || k == IOCTL;  /* MM (== 0) or FS (== 1). */
| #else
|   k = (_M.m_type & 17) != 1;  /* _M.m_type is syscall number. */  /* MM (== 0) or FS (== 1). */  /* This works for EXIT (MM), READ, WRITE, OPEN, CLOSE, CREAT, BRK (MM) and IOCTL. */
| #endif
|   k = sendrec(k, &_M);
|   if (k != 0) return(k);  /* send itself failed */
|   if (_M.m_type < 0) {
| #ifdef ERRNO  /* Always false. */
|     errno = -_M.m_type;
| #endif
|     return(-1);
|   }
|   return(_M.m_type);
| }
.data
.text
	mov ax, [__M+2]  | syscall number.
	andb al, *15
	dec ax
	jz callxmmfs  | Keep AX == MM (== 0).
	movb al, *1  | AX := FS (== 1).
callxmmfs:
	| Now AX is either MM (== 0) or FS (== 1), depending on the syscall number.
	mov bx, #__M
	mov cx, #BOTH  | sendrec(srcdest, ptr)
	int SYSVEC  | trap to the kernel; ruins AX, BX and CX, keeps DX.
	test ax, ax
	jnz callxret  | sendrec(...) itself has failed.
	or ax, [__M+2]  | Syscall result or -errno.
	movb [__M+3], *0  | Set high byte of next syscall to 0.
	jns callxret
	| Here, if ERRNO is defined, we should set:
	|neg ax
	|mov [_errno], ax
	mov ax, #-1  | Return value to indicate syscall error.
callxret:
	ret

| int read(int fd, char *buffer, unsigned nbytes);
.globl _read
_read:
	movb [__M+2], *3  | *(char*)&_M.m_type = READ;
readwrite:
	mov bx, sp
	mov ax, 2(bx)  | Argument fd.
	mov [__M+4], ax  | _M.m1_i1.
	mov ax, 4(bx)  | Argument buffer.
	mov [__M+10], ax  | _M.m1_p1.
	mov ax, 6(bx)  | Argument nbytes.
	mov [__M+6], ax  | _M.m1_i2.
	j _callx

| int write(int fd, const char *buffer, unsigned nbytes);
.globl _write
_write:
	movb [__M+2], *4  | *(char*)&_M.m_type = WRITE;
	j readwrite

| int close(int fd);
.globl _close
_close:
	movb [__M+2], *6  | *(char*)&_M.m_type = CLOSE;
	| Argument fd will be copied to _M.m1_i1.
callxarg1:
	mov bx, sp
	mov ax, 2(bx)  | Argument 1.
	mov [__M+4], ax  | _M.m1_i1.
j_callx:
	j _callx

if F_UMASK
| mode_t umask(mode_t complmode);
.globl _umask
_umask:
| PUBLIC mode_t umask(complmode) mode_t complmode {
|   return((mode_t)callm1(FS, UMASK, (int)complmode, 0, 0, NIL_PTR, NIL_PTR, NIL_PTR));
| }
	movb [__M+2], *60  | *(char*)&_M.m_type = UMASK;
	j callxarg1  | Argument complmode will be copied to _M.m1_i1.
endif

if F_FSTAT
| int fstat(int fd, struct stat *buffer);
.globl _fstat
_fstat:
| PUBLIC int fstat(fd, buffer)
| int fd;
| struct stat *buffer;
| {
|   return(callm1(FS, FSTAT, fd, 0, 0, (char *)buffer, NIL_PTR, NIL_PTR));
| }
	movb [__M+2], *28  | *(char*)&_M.m_type = FSTAT;
	mov bx, sp
	mov ax, 4(bx)  | Argument buffer.
	mov [__M+10], ax  | _M.m1_p1.
	j callxarg1  | Argument fd will be copied to _M.m1_i1.
endif

| int open00(const char *name);
.globl _open00
_open00:
	movb [__M+2], *5  | *(char*)&_M.m_type = OPEN;
	xor ax, ax  | AX (flags) := 0. Will be saved to _M.m3_i2.
	| _M.m3_i2 := flags.  | Fall through to callm3ax.

callm3ax:
	mov [__M+6], ax  | _M.m3_i2 = mode;
	| Fall through to callm3.

| int callm3(const char *name);
|
| This form of system call is used for those calls that contain at most
| one integer parameter along with a string.  If the string fits in the
| message, it is copied there.  If not, a pointer to it is passed.
callm3:
| PUBLIC int callm3(name) _CONST char *name; {
|   register unsigned k;
|   register char *rp;
|   k = strlen(name) + 1;
|   _M.m3_i1 = k;
|   _M.m3_p1 = (char *) name;
|   rp = &_M.m3_ca1[0];
|   if (k <= M3_STRING) {  /* 14. */
|     while (k--) { *rp++ = *name++; }
|   }
|   return callx();
| }
	push si  | Save.
	mov si, sp
	mov si, 4(si)  | Argument name.
	mov [__M+8], si  | _M.m3_p1 = (char *) name;
	push si  | Argument name.
	call _strlen
	pop cx  | Clean up argument of _strlean above.
	inc ax  | k := strlen(name) + 1.
	mov [__M+4], ax  | _M.m3_i1 = k;
	cmp ax, *14  | if (k <= M3_STRING)
	ja callm3skip
	xchg cx, ax  | CX := AX (k); AX := junk.
	xchg di, ax  | Save DI to AX.
	mov di, #__M+10  | rp = &_M.m3_ca1[0];
	rep
	movb
	xchg di, ax  | Restore DI from AX. AX := junk.
callm3skip:
	pop si  | Restore.
	j j_callx

| int creat(const char *name, mode_t mode);
.globl _creat
_creat:
	movb [__M+2], *8  | *(char*)&_M.m_type = CREAT;
callm3arg2:
	mov bx, sp
	mov ax, 4(bx)  | Argument mode.
	j callm3ax  | _M.m3_i2 = mode.

if F_CHMOD
| int chmod(const char *name, mode_t mode);
.globl _chmod
_chmod:
| PUBLIC int chmod(name, mode)
| _CONST char *name;
| mode_t mode;
| {
|   return(callm3(FS, CHMOD, mode, name));
| }
	movb [__M+2], *15  | *(char*)&_M.m_type = CHMOD;
	j callm3arg2
endif

if F_ISATTY
| int isatty(int fd);
.globl _isatty
_isatty:
| int isatty(fd) int fd; {  /* Minix 1.5--1.7.2. */
|   _M.TTY_REQUEST = 0x7408;  /* TIOCGETP == 0x7408 on Minix 1.5.10. */  /* #define TTY_REQUEST m2_i3 */
|   _M.TTY_LINE = fd;  /* #define TTY_LINE m2_i1 */
|   return(callx(FS, IOCTL) >= 0);  /* FS == 1; IOCTL == 54. */
| }
| int isatty(fd) int fd; {  /* Minix 1.7.4--2.0.4--3.2.0, merged isatty(...), tcgetattr(...) and ioctl(...) */
|  struct termios dummy;  /* sizeof(struct termios) == 36 == 0x24 on i386, == 32 == 0x20 on i86. */
|  m.TTY_REQUEST = (unsigned) (0x80245408L & ~(unsigned) 0);  /* TCGETS == (int) 0x80245408L on Minix 2.0.4 */  /* #define TTY_REQUEST COUNT */  /* #define COUNT m2_i3 */
|  m.TTY_LINE = fd;  /* #define TTY_LINE DEVICE */  /* #define DEVICE m2_i1 */
|  m.ADDRESS = (char *) &dummy;  /* #define ADDRESS m2_p1 */ 
|  return((callx(FS, IOCTL) >= 0);  /* FS == 1; IOCTL == 54. */  /* Actually, Minix does (...) == 0. */
| }
| int isatty(fd) int fd; {  /* Our implementation below, compatible with Minix 1.5--2.0.4--3.2.0. */
|   char dummy[sizeof(int) == 2 ? 32 : 36];  /* struct termios dummy; */  /* For compatibility with Minix 1.7.4--2.0.4--3.2.0. */
|   _M.TTY_REQUEST = 0x7408;  /* TIOCGETP; */
|   _M.TTY_LINE = fd;
|   if (callx(FS, IOCTL) >= 0) goto found_tty;  /* Minix 1.5--1.7.2. */
|   _M.TTY_REQUEST = (unsigned) (0x80245408L & ~(unsigned) 0);  /* TCGETS. */
|   _M.TTY_LINE = fd;
|   _M.ADDRESS = dummy;
|   if (callx(FS, IOCTL) < 0) return 0;  /* Minix 1.7.4--2.0.4--3.2.0. */
|  found_tty:
|   return(1);
| }
	| First try: Minix 1.5--1.7.2.
	movb [__M+2], *54  | *(char*)&_M.m_type = IOCTL;
	mov [__M+8], #$7408  | _M.TTY_REQUEST = Minix_1_5_TIOCGETP;
	mov bx, sp
	mov ax, 2(bx)  | Argument fd.
	mov [__M+4], ax  | _M.TTY_LINE = fd;
	call _callx  | if (callx() >= 0) goto isattydone;
	test ax, ax
	jns isattydone  | Jump iff found a TTY.
	| Not found a TTY for the first try. Second try: Minix 1.7.4--2.0.4--3.2.0.
	mov [__M+8], #$5408  | _M.TTY_REQUEST = Minix_1_7_2_TIOCGETP;
	mov bx, sp
	mov ax, 2(bx)  | Argument fd.
	mov [__M+4], ax  | _M.TTY_LINE = fd;
	sub sp, *32  | struct termios &dummy;
	mov [__M+18], sp  | _M.ADDRESS = &dummy.  | m2_p1.
	call _callx  | if (callx() >= 0) goto isattydone;
	add sp, *32  | Pop the dummy.
isattydone:  | return callx() >= 0;
	| This would be 1 byte longer.
	|test ax, ax
	|mov ax, #1
	|jns isattyret
	|dec ax  | AX := 0.
	rol ax, *1
	not ax
	and ax, *1
|isattyret:
	ret
endif

if F_LSEEK
| off_t lseek(int fd, off_t offset, int whence);
.globl _lseek
_lseek:
| PUBLIC off_t lseek(fd, offset, whence)
| int fd;
| off_t offset;
| int whence;
| {
|   int k;
|   *(char*)&_M.m_type = LSEEK;
|   _M.m2_i1 = fd;
|   _M.m2_l1 = offset;
|   _M.m2_i2 = whence;
|   if ((k = callx()) != 0) return((off_t) k);
|   return((off_t) _M.m2_l1);
| }
	mov bx, si  | Save SI to BX.
	mov si, sp
	lods  | SI += 2; AX := junk.
	movb [__M+2], *19  | *(char*)&_M.m_type = LSEEK;
	lods  | Argument fd.
	mov [__M+4], ax
	lods  | Low  word of argument offset.
	mov [__M+10], ax
	lods  | High word of argument offset.
	mov [__M+12], ax
	lods  | Argument whence.
	mov si, bx  | Restore SI from BX.
	mov [__M+6], ax
	call _callx
	test ax, ax  | if ((k = callx()) != 0)
	jz lseekcopyofs
	cwd  | return((off_t) k);
	j lseekret
lseekcopyofs:
	mov ax, [__M+10]
	mov dx, [__M+12]  | return((off_t) _M.m2_l1);
lseekret:
	ret  | Return result in DX:AX.
endif

| char *brk(char *addr);
.globl _brk
_brk:
| PUBLIC char *brk(addr) char *addr; {
|   *(char*)&_M.m_type = BRK;
|   _M.m1_p1 = addr;
|   if (callx() == 0) {
|     brksize = _M.m2_p1;
|     return((char*) 0);
|   } else {
|     return((char *) -1);
|   }
| }
	movb [__M+2], *17  | *(char*)&_M.m_type = BRK;
	mov bx, sp
	mov bx, 2(bx)  | Argument addr.
	mov [__M+10], bx
	call _callx
	test ax, ax
	jnz brkerror
	mov bx, [__M+18]  | _M.m2_p1.
	mov [_brksize], bx  | brksize = _M.m2_p1;
	j brkret
brkerror:
	mov ax, #-1  | return((char *) -1);
brkret:
	ret

| --- C compiler integer operation helpers.

| !! Omit the unused int and long operations below.

| idiv_ doesn't preserve dx (returns remainder in it)
.globl idiv_
idiv_:
	cwd
	idiv bx
	ret

| idiv_u doesn't preserve dx (returns remainder in it)
.globl idiv_u
idiv_u:
	xor dx, dx
	div bx
	ret

| imodu doesn't preserve edx/dx (returns quotient in it)
.globl imodu
imodu:
	xor dx, dx
	div bx
	mov ax, dx  | instruction queue full so xchg slower
	ret

| imul_, imul_u don't preserve dx
.globl imul_
.globl imul_u
imul_:
imul_u:
	imul bx
	ret

.globl laddl
.globl laddul
laddl:
laddul:
	add ax, (di)
	adc bx, 2(di)
	ret

.globl landl
.globl landul
landl:
landul:
	and ax, (di)
	and bx, 2(di)
	ret

| lcmpl, lcmpul don't preserve bx
.globl lcmpl
.globl lcmpul
lcmpl:
lcmpul:
	sub bx, 2(di)  | don't need to preserve bx
	jne LCMP_EXIT
LCMP_NOT_SURE:
	cmp ax, (di)
	jb LCMP_B_AND_LT | b (below) becomes lt (less than) as well
	jge LCMP_EXIT | ge and already ae
	  | else make gt as well as a (above)
	inc bx  | clear ov and mi, set ne for greater than
LCMP_EXIT:
	ret
LCMP_B_AND_LT:
	dec bx  | clear ov, set mi and ne for less than
	ret

.globl lcoml
.globl lcomul
lcoml:
lcomul:
	not ax
	not bx
	ret

.globl ldecl
.globl ldecul
ldecl:
ldecul:
	cmp word ptr (bx), *0
	jne LDEC_LOW
	dec word ptr 2(bx)
LDEC_LOW:
	dec word ptr (bx)
	ret

.globl leorl
.globl leorul
leorl:
leorul:
	xor ax, (di)
	xor bx, 2(di)
	ret

.globl lincl
.globl lincul
lincl:
lincul:
	inc word ptr (bx)
	jnz LINC_RET
LINC_HIGH_WORD:
	inc word ptr 2(bx)
LINC_RET:
	ret

| lmull, lmulul don't preserve cx, dx
.globl lmull
.globl lmulul
lmull:
lmulul:
	mov cx, ax
	mul word ptr 2(di)
	xchg ax, bx
	mul word ptr (di)
	add bx, ax
	mov ax, ptr (di)
	mul cx
	add bx, dx
	ret

.globl lnegl
.globl lnegul
lnegl:
lnegul:
	neg bx
	neg ax
	sbb bx, *0
	ret

.globl lorl
.globl lorul
lorl:
lorul:
	or ax, (di)
	or bx, 2(di)
	ret

| lsll, lslul don't preserve cx
.globl lsll
.globl lslul
lsll:
lslul:
	mov cx, di
	jcxz LSL_EXIT
	cmp cx, *32
	jae LSL_ZERO
LSL_LOOP:
	shl ax, *1
	rcl bx, *1
	loop LSL_LOOP
LSL_EXIT:
	ret
LSL_ZERO:
	xor ax, ax
	mov bx, ax
	ret

| lsrl doesn't preserve cx
.globl lsrl
lsrl:
	mov cx, di
	jcxz LSR_EXIT
	cmp cx, *32
	jae LSR_SIGNBIT
LSR_LOOP:
	sar bx, *1
	rcr ax, *1
	loop LSR_LOOP
LSR_EXIT:
	ret
LSR_SIGNBIT:
	mov cx, *32  | equivalent to +infinity in this context
	j LSR_LOOP

| lsrul doesn't preserve cx
.globl lsrul
lsrul:
	mov cx, di
	jcxz LSRU_EXIT
	cmp cx, *32
	jae LSRU_ZERO
LSRU_LOOP:
	shr bx, *1
	rcr ax, *1
	loop LSRU_LOOP
LSRU_EXIT:
	ret
LSRU_ZERO:
	xor ax, ax
	mov bx, ax
	ret

.globl lsubl
.globl lsubul
lsubl:
lsubul:
	sub ax, (di)
	sbb bx, 2(di)
	ret

| ltstl, ltstul don't preserve bx
.globl ltstl
.globl ltstul
ltstl:
ltstul:
	test bx, bx
	jnz LTST_RET
LTST_NOT_SURE:
	test ax, ax
	js LTST_FIX_SIGN
	ret
LTST_FIX_SIGN:
	inc bx  | clear ov and mi, set ne for greater than
LTST_RET:
	ret

if F_ISRU
| isru doesn't preserve cl
.globl isru
isru:
	mov cl, bl
	shr ax, cl
	ret
endif

if F_LDIVMOD
| Divides signed 32-bit long dividend BX:AX by signed 32-bit long divisor [DI+2]:[DI], rounds towards 0, saves the quotient to DI:CX, saves the remainder to BX:AX. Ruins DX and FLAGS. Traps on division by 0 or overflow.
.globl lmodl
|.extern __I4D
lmodl:
	mov dx, (di)
	mov cx, 2(di)
	xchg dx, bx
	call __I4D
	mov di, dx
	xchg cx, ax
	xchg bx, ax
	ret
endif

if F_LDIVMOD
| Divides unsigned 32-bit long dividend BX:AX by unsigned 32-bit long divisor [DI+2]:[DI], rounds towards 0 (same as rounding down for unsigned) saves the quotient to DI:CX, saves the remainder to BX:AX. Ruins DX and FLAGS. Traps on division by 0 or overflow.
.globl lmodul
|.extern __U4D
lmodul:
	mov dx, (di)
	mov cx, 2(di)
	xchg dx, bx
	call __U4D
	mov di, dx
	xchg cx, ax
	xchg bx, ax
	ret
endif

if F_LDIVMOD
| Divides signed 32-bit long dividend BX:AX by signed 32-bit long divisor [DI+2]:[DI], rounds towards 0, saves the quotient to BX:AX, saves the remainder to DI:CX. Ruins DX and FLAGS. Traps on division by 0 or overflow.
.globl ldivl
|.extern __I4D
ldivl:
	mov dx, (di)
	mov cx, 2(di)
	xchg dx, bx
	call __I4D
	mov di, cx
	mov cx, bx
	mov bx, dx
	ret
endif

if F_LDIVMOD
| Divides unsigned 32-bit long dividend BX:AX by unsigned 32-bit long divisor [DI+2]:[DI], rounds towards 0 (same as rounding down for unsigned) saves the quotient to BX:AX, saves the remainder to DI:CX. Ruins DX and FLAGS. Traps on division by 0 or overflow.
.globl ldivul
|.extern __U4D
ldivul:
	mov dx, (di)
	mov cx, 2(di)
	xchg dx, bx
	call __U4D
	mov di, cx
	mov cx, bx
	mov bx, dx
	ret
endif

if F_LDIVMOD
| Divides signed 32-bit long dividend DX:AX by signed 32-bit long divisor CX:BX, rounds towards 0, saves the quotient to DX:AX, saves the remainder to CX:BX. Ruins FLAGS. Traps on division by 0 or overflow.
| Based on OpenWatcom v2 libc.
__I4D:
	test dx, dx
	js i4ddividendneg
	test cx, cx
	jns __U4D
	neg cx
	neg bx
	sbb cx, *0
	call __U4D
	j i4dqneg
i4ddividendneg:
	neg dx
	neg ax
	sbb dx, *0
	test cx, cx
	jns i4drneg
	neg cx
	neg bx
	sbb cx, *0
	call __U4D
	neg cx
	neg bx
	sbb cx, *0
	ret
i4drneg:
	call __U4D
	neg cx
	neg bx
	sbb cx, *0
i4dqneg:
	neg dx
	neg ax
	sbb dx, *0
	ret

| Divides unsigned 32-bit long dividend DX:AX by unsigned 32-bit long divisor CX:BX, rounds towards 0 (same as rounding down for unsigned) saves the quotient to DX:AX, saves the remainder to CX:BX. Ruins FLAGS. Traps on division by 0 or overflow.
| Based on OpenWatcom v2 libc.
__U4D:
	test cx, cx
	jnz u4dlargedivisor  | Jumps iff the divisor doesn't fit to a 16-bit word.
	dec bx
	je u4dretsmall  | If dividing by 1, it's a no-op, keep the quotient in DX:AX, and keep the remainder 0 in CX:BX.
	inc bx
	cmp bx, dx
	ja u4dlow  | Jumps iff the quotient fits to a 16-bit word, i.e. if the divisor BX is larger than high word of the dividend (DX). If it jumps, it stores the high word of the quotient in CX, which is 0.
	mov cx, ax
	mov ax, dx
	xor dx, dx
	div bx  | This traps on division by zero.
	xchg ax, cx
u4dlow:
	div bx
	mov bx, dx  | BX := low word of the remainder.
	mov dx, cx  | DX := high word of the quotient.
	xor cx, cx  | DX := high word of the remainder. It's 0, because the remainder is smaller than the divisor, and the divisor fits to a 16-bit word, so the remainder also does.
u4dretsmall:
	ret
u4dlargedivisor:
	cmp cx, dx
	jb u4dqnonzero  | Jumps iff the high word of the dividend is larger than the high word of the divisor.
	jne u4dqzero
	cmp bx, ax
	ja u4dqzero  | Jumps iff the divisor is larger than the dividend.
u4dqone:
	sub ax, bx  | AX := low word of the remainder.
	xchg bx, ax  | BX := AX| AX := junk.
	xor cx, cx  | Set high word of the remainder to 0.
	mov ax, *1
	cwd  | Set the quotient (DX:AX) to 1.
	ret
u4dqzero:
	xor cx, cx
	xor bx, bx  | CX:BX := 0.
	xchg ax, bx
	xchg dx, cx  | Set the remainder (CX:BX) to the dividend, and the quotient (DX:AX) to 0.
	ret
u4dqnonzero:
	push bp
	push si
	xor si, si
	mov bp, si
loc8:
	add bx, bx
	adc cx, cx
	jb loc11
	inc bp
	cmp cx, dx
	jb loc8
	ja loc9
	cmp bx, ax
	jbe loc8
loc9:
	clc
loc10:
	adc si, si
	dec bp
	js loc14
loc11:
	rcr cx, *1
	rcr bx, *1
	sub ax, bx
	sbb dx, cx
	cmc
	jb loc10
loc12:
	add si, si
	dec bp
	js loc13
	shr cx, *1
	rcr bx, *1
	add ax, bx
	adc dx, cx
	jae loc12
	j loc10
loc13:
	add ax, bx
	adc dx, cx
loc14:
	mov bx, ax
	mov cx, dx
	mov ax, si
	xor dx, dx
	pop si
	pop bp
	ret
endif

| --- C library string functions (str...(3) and mem...(3)).

if F_MEMCPY
| void *memcpy(void *s1, const void *s2, size_t n);
|
| Copies n characters from the object pointed to by s2 into the
| object pointed to by s1.  Copying takes place as if the n
| characters pointed to by s2 are first copied to a temporary
| area and then copied to the object pointed to by s1.
| Returns s1.
|
| Per X3J11, memcpy may have undefined results if the objects
| overlap; since the performance penalty is insignificant, we
| use the safe memmove code for it as well.
.globl _memcpy
_memcpy:
	mov bx, si  | Save SI to BX.
	mov dx, di  | Save DI to DX.
	mov di, sp
	mov cx, 6(di)  | Argument n.
	mov si, 4(di)  | Argument s2.
	mov di, 2(di)  | Argument s1.
	mov ax, di  | Save a copy of s1, for returning.
	rep
	movb
	mov di, dx  | Restore DI. DX := junk.
	mov si, bx  | Restore SI. BX := junk.
	ret
endif

if F_MEMSET
| void *memset(void *s, int c, size_t n);
|
| Copies the value of c (converted to unsigned char) into the
| first n locations of the object pointed to by s.
| Returns s.
.globl _memset
_memset:
	mov dx, di  | Save DI to DX.
	mov di, sp
	mov cx, 6(di)  | Argument n.
	movb al, 4(di)  | Argument c.
	mov di, 2(di)  | Argument s.
	mov bx, di  | Save a copy of s, for returning.
	rep
	stob
	xchg ax, bx  | AX := s; BX := junk.
	mov di, dx  | Restore DI. DX is now junk.
	ret
endif

| int strcmp(const char *s1, const char *s2);
|
| Compares the strings pointed to by s1 and s2.  Returns zero if
| strings are identical, a positive number if s1 greater than s2,
| and a negative number otherwise.
.globl _strcmp
_strcmp:
	mov bx, si  | Save SI to BX.
	mov dx, di  | Save DI to DX.
	mov si, sp
	mov di, 4(si)  | Argument s2.
	mov si, 2(si)  | Argument s1.
strcmpnext:
	lodb
	scab
	jne strcmpdiff
	cmp al, *0
	jne strcmpnext
	xor ax, ax
	j strcmpdone
strcmpdiff:
	sbb ax, ax
	orb al, *1
strcmpdone:
	mov di, dx  | Restore DI. DX := junk.
	mov si, bx  | Restore SI. BX := junk.
	ret

| char *strcpy(char *s1, const char *s2);
|
| Copy the string pointed to by s2, including the terminating null
| character, into the array pointed to by s1.  Returns s1.
.globl _strcpy
_strcpy:
if F_STRCAT
	call strcpysetup
else
	mov bx, si  | Save SI to BX.
	mov dx, di  | Save DI to DX.
	mov di, sp
	mov si, 4(di)  | Argument s2.
	mov di, 2(di)  | Argument s1.
	mov cx, di  | Save a copy of s1, for returning.
endif
strcpynext:
	lodb
	stob
	testb al, al
	jnz strcpynext
	xchg ax, cx  | AX := s1; CX := junk.
	mov di, dx  | Restore DI. DX := junk.
	mov si, bx  | Restore SI. BX := junk.
	ret
if F_STRCAT
strcpysetup:  | Code shared by _strcpy and _strcat.
	mov bx, si  | Save SI to BX.
	mov dx, di  | Save DI to DX.
	mov di, sp
	mov si, 6(di)  | Argument s2.
	mov di, 4(di)  | Argument s1.
	mov cx, di  | Save a copy of s1, for returning.
	ret
endif

if F_STRCAT
| char *strcat(char *s1, const char *s2)
|
| Concatenates the string pointed to by s2 onto the end of the
| string pointed to by s1.  Returns s1.
.globl _strcat
_strcat:
	call strcpysetup
	movb al, *0
strcatnext:
	scab
	jne strcatnext
	dec di  | Undo the skipping over the last NUL.
	j strcpynext
endif

| size_t strlen(const char *s);
|
| Returns the length of the string pointed to by s.
.globl _strlen
_strlen:
	mov bx, di  | Save DI.
	mov di, sp
	mov di, 2(di)  | Argument s.
	mov cx, #-1
	xorb al, al  | Also sets ZF := 1, which is needed below for the emptry string.
	repne
	scab
	not cx  | Silly trick gives length (including the NUL byte).
	dec cx  | Forget about the NUL byte.
	xchg ax, cx  | AX := result; CX := junk.
	mov di, bx  | Restore DI. BX is now junk.
	ret

if F_STRRCHR
| char *strrchr(const char *s, int c);
|
| Locates final occurrence of c (as unsigned char) in string s.
.globl _strrchr
_strrchr:
	mov bx, si  | Save SI.
	mov si, sp
	mov ah, 4(si)  | Argument c.
	mov si, 2(si)  | Argument s.
	xor dx, dx  | Initial return value of NULL.
strrchrnext:
	lodsb
	cmp al, ah
	jne strrchrdiff
	mov dx, si
	dec dx  | Make DX point to the last occurrence c, not after it.
strrchrdiff:
	testb al, al
	jnz strrchrnext
	xchg ax, dx  | AX := pointer to last match; DX := junk.
	mov si, bx  | Restore SI. BX is now junk.
	ret
endif

if F_STRNCMP
| int strncmp(const char *s1, const char *s2, size_t n);
|
| Compares up to n characters from the strings pointed to by s1
| and s2.  Returns zero if the (possibly null terminated) arrays
| are identical, a positive number if s1 is greater than s2, and
| a negative number otherwise.
.globl _strncmp
_strncmp:
	mov bx, si  | Save SI to BX.
	mov dx, di  | Save DI to DX.
	mov si, sp
	mov cx, 6(si)  | Argument n.
	jcxz strncmpequal
	mov di, 4(si)  | Argument s2.
	mov si, 2(si)  | Argument s1.
strncmpnext:
	lodsb
	scasb
	je strncmpsame
	sbb ax, ax
	sbb ax, *-1  | With the previous instruction: AX := (CF ? -1 : 1).
	j strncmpret
strncmpsame:
	testb al, al
	jz strncmpequal
	loop strncmpnext
strncmpequal:
	xor ax, ax
strncmpret:
	mov di, dx  | Restore DI. DX := junk.
	mov si, bx  | Restore SI. BX := junk.
	ret
endif

if F_MEMCMP
| int memcmp(const void *s1, const void *s2, size_t n)
|
| Compares the first n characters of the objects pointed to by
| s1 and s2.  Returns zero if all characters are identical, a
| positive number if s1 greater than s2, a negative number otherwise.
.globl _memcmp
_memcmp:
	mov bx, si  | Save SI to BX.
	mov dx, di  | Save DI to DX.
	mov si, sp
	mov cx, 6(si)  | Argument n.
	mov di, 4(si)  | Argument s2.
	mov si, 2(si)  | Argument s1.
	xor ax, ax  | Also sets ZF := 1, which is needed below for the emptry string.
	rep  | Same as repe (continue while equal) for cmpsb.
	cmpb
	je memcmpret
	inc ax
	jnc memcmpret
	neg ax
memcmpret:
	mov di, dx  | Restore DI. DX := junk.
	mov si, bx  | Restore SI. BX := junk.
	ret
endif

| __END__
